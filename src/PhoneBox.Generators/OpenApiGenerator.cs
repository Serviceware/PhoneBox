using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Interfaces;
using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Readers;

namespace PhoneBox.Generators
{
    [Generator]
    public sealed class OpenApiGenerator : IIncrementalGenerator
    {
        private static readonly Assembly ThisAssembly = typeof(OpenApiGenerator).Assembly;
        private static readonly string AttributeTypeName = typeof(OpenApiGenerationAttribute).FullName;
        private static readonly string DefaultAnnotationsStr = ComputeDefaultAnnotationsStr();
        private static readonly string GeneratedCodeAnnotationStr = ComputeGeneratedCodeAnnotationStr();
        private const string EmbeddedSourcePrefix = $"{nameof(PhoneBox)}.{nameof(Generators)}.EmbeddedSources";
        private const string EnumVarNamesExtension = "x-enum-varnames";
        private const string GeneratedCodeHeader = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValueProvider<string?> rootNamespace = context.AnalyzerConfigOptionsProvider.Select((x, _) => GetRootNamespace(x));
            IncrementalValueProvider<string?> assemblyName = context.CompilationProvider.Select((x, _) => x.AssemblyName);
            IncrementalValueProvider<ImmutableArray<SignalRHubGenerationOutputs?>> outputFilter = context.SyntaxProvider
                                                                                                         .CreateSyntaxProvider(IsAssemblyAttribute, CollectOutputFilter)
                                                                                                         .Collect();
            IncrementalValuesProvider<OpenApiDocumentContainer> documents = context.AdditionalTextsProvider
                                                                                   .Where(static file => file.Path.EndsWith(".yml", StringComparison.OrdinalIgnoreCase))
                                                                                   .Select(LoadYamlFile)
                                                                                   .Where(x => x.HasValue)
                                                                                   .Select((x, _) => x!.Value);

            var all = documents.Combine(context.AnalyzerConfigOptionsProvider)
                               .Combine(outputFilter)
                               .Combine(rootNamespace)
                               .Combine(assemblyName)
                               .Select(static (x, _) => new
                               {
                                   Container = x.Left.Left.Left.Left,
                                   RootNamespace = x.Left.Right,
                                   AssemblyName = x.Right,
                                   OutputFilter = x.Left.Left.Right.FirstOrDefault(x => x != null) ?? SignalRHubGenerationOutputs.All,
                                   AnalyzerConfigOptionsProvider = x.Left.Left.Left.Right
                               });

            context.RegisterSourceOutput(all, (x, y) => CollectSources(x, y.Container, y.RootNamespace, y.AssemblyName, y.OutputFilter, y.AnalyzerConfigOptionsProvider));
            context.RegisterPostInitializationOutput(RegisterPostInitializationOutput);
        }

        private static void CollectSources(SourceProductionContext context, OpenApiDocumentContainer container, string? rootNamespace, string? assemblyName, SignalRHubGenerationOutputs outputFilter, AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider)
        {
            AnalyzerConfigOptions options = analyzerConfigOptionsProvider.GetOptions(container.SourceFile);
            string? configuredNamespace = GetMetadataProperty(options, "build_metadata.none.Namespace");
            string? hubNamespace = GetMetadataProperty(options, "build_metadata.none.HubNamespace");
            string? contractNamespace = GetMetadataProperty(options, "build_metadata.none.ContractNamespace");

            ReportOpenApiErrors(context, container.Path, container.Diagnostic);

            string defaultNamespace = configuredNamespace ?? rootNamespace ?? assemblyName ?? "PhoneBox.Generated";
            IDictionary<string, OpenApiModel> modelMap = CollectModels(context, container.Path, container.Document.Components.Schemas).ToDictionary(x => x.Name);
            IDictionary<OpenApiOperationGroupKey, OpenApiOperationGroup> operationGroupMap = new Dictionary<OpenApiOperationGroupKey, OpenApiOperationGroup>();
            ICollection<OpenApiOperationGroup> operationGroups = operationGroupMap.Values;
            CollectOperations(container, operationGroupMap, modelMap);
            
            foreach (OpenApiModel model in modelMap.Values)
            {
                if (model.Usage == OpenApiModelUsage.None)
                    continue;

                if (outputFilter.HasFlag(model.Usage == OpenApiModelUsage.Service ? SignalRHubGenerationOutputs.Implementation : SignalRHubGenerationOutputs.Model)) 
                    AddModel(context, defaultNamespace, model);
            }

            foreach (OpenApiOperationGroup operationGroup in operationGroups)
            {
                bool isWebSocket = operationGroup.IsWebSocket;
                
                string interfaceName;
                string className;
                if (isWebSocket)
                {
                    string hubName = NormalizeHubName(operationGroup.Name);
                    interfaceName = $"I{hubName}Hub";
                    className = $"{hubName}Hub";
                }
                else
                {
                    interfaceName = $"I{operationGroup.Name}";
                    className = operationGroup.Name;
                }

                if (outputFilter.HasFlag(isWebSocket ? SignalRHubGenerationOutputs.Model : SignalRHubGenerationOutputs.Implementation))
                    AddInterface(context, interfaceName, defaultNamespace, contractNamespace, isWebSocket, operationGroup.Operations, modelMap);

                if (outputFilter.HasFlag(SignalRHubGenerationOutputs.Implementation))
                {
                    if (isWebSocket)
                    {
                        AddHub(context, className, hubNamespace, interfaceName, defaultNamespace, contractNamespace);
                    }
                    else
                    {
                        AddService(context, className, interfaceName, defaultNamespace, isWebSocket);
                    }
                }
            }

            if (outputFilter.HasFlag(SignalRHubGenerationOutputs.Implementation))
            {
                ICollection<OpenApiOperationGroup> hubs = operationGroups.Where(x => x.IsWebSocket).ToArray();
                if (hubs.Any())
                {
                    AddHubExtensions(context, defaultNamespace, hubNamespace, hubs);
                }

                ICollection<OpenApiOperationGroup> endpoints = operationGroups.Where(x => !x.IsWebSocket).ToArray();
                if (endpoints.Any())
                {
                    AddEndpointExtensions(context, defaultNamespace, contractNamespace, endpoints, modelMap);
                }
            }
        }

        private static void RegisterPostInitializationOutput(IncrementalGeneratorPostInitializationContext context)
        {
            foreach (string resourceName in ThisAssembly.GetManifestResourceNames())
            {
                if (!resourceName.StartsWith(EmbeddedSourcePrefix, StringComparison.Ordinal)) 
                    continue;

                string fileName = resourceName.Substring(EmbeddedSourcePrefix.Length + 1);
                int extensionIndex = fileName.LastIndexOf('.');
                if (extensionIndex < 0) 
                    extensionIndex = fileName.Length;

                fileName = fileName.Insert(extensionIndex, ".g");
                
                string content;
                using (Stream stream = ThisAssembly.GetManifestResourceStream(resourceName)!)
                {
                    using (TextReader reader = new StreamReader(stream))
                    {
                        content = reader.ReadToEnd();
                    }
                }

                context.AddSource(fileName, $@"{GeneratedCodeHeader}

{NormalizeEmbeddedSource(content)}");
            }
        }

        private static void AddService(SourceProductionContext context, string className, string interfaceName, string defaultNamespace, bool isWebSocket)
        {
            string visibility = isWebSocket ? "public" : "internal";
            string fileName = $"{className}.g.cs";
            string content = $@"{GeneratedCodeHeader}

namespace {defaultNamespace}
{{
    {visibility} partial class {className} : global::{defaultNamespace}.{interfaceName}
    {{
    }}
}}";
            context.AddSource(fileName, content);
        }

        private static void AddHub(SourceProductionContext context, string className, string? hubNamespace, string interfaceName, string defaultNamespace, string? contractNamespace)
        {
            string fileName = $"{className}.g.cs";
            string content = $@"{GeneratedCodeHeader}

namespace {hubNamespace ?? defaultNamespace}
{{
    public partial class {className} : global::Microsoft.AspNetCore.SignalR.Hub<global::{contractNamespace ?? defaultNamespace}.{interfaceName}>
    {{
    }}
}}";
            context.AddSource(fileName, content);
        }

        private static void AddInterface(SourceProductionContext context, string interfaceName, string defaultNamespace, string? contractNamespace, bool isWebSocket, IEnumerable<OpenApiOperationDescriptor> methods, IDictionary<string, OpenApiModel> modelMap)
        {
            string visibility = isWebSocket ? "public" : "internal";
            string fileName = $"{interfaceName}.g.cs";

            string CollectMethod(OpenApiOperationDescriptor method) => isWebSocket ? GenerateHubInterfaceMethod(method, defaultNamespace, contractNamespace, modelMap) : GenerateServiceInterfaceMethod(method, defaultNamespace, contractNamespace, modelMap);

            string methodsStr = String.Join(Environment.NewLine, methods.Select(CollectMethod));
            string content = $@"{GeneratedCodeHeader}

namespace {defaultNamespace}
{{
{GeneratedCodeAnnotationStr}
    {visibility} interface {interfaceName}
    {{
{methodsStr}
    }}
}}";
            context.AddSource(fileName, content);
        }

        private static void AddModel(SourceProductionContext context, string defaultNamespace, OpenApiModel model)
        {
            string content = GenerateModel(defaultNamespace, model);
            context.AddSource($"{model.Name}.g.cs", content);
        }

        private static string GenerateModel(string defaultNamespace, OpenApiModel model)
        {
            switch (model)
            {
                case OpenApiClass @class: return GenerateClass(defaultNamespace, @class);
                case OpenApiEnum @enum: return GenerateEnum(defaultNamespace, @enum);
                default: throw new ArgumentOutOfRangeException(nameof(model), model, null);
            }
        }

        private static string GenerateClass(string defaultNamespace, OpenApiClass @class)
        {
            string visibility = @class.Usage == OpenApiModelUsage.Service ? "internal" : "public";
            string propertiesStr = String.Join(Environment.NewLine, @class.Properties.Select(x => $"        public {x.TypeName.GetGlobalTypeName(defaultNamespace)} {ToPascalCase(x.PropertyName)} {{ get; }}"));
            string ctorParametersStr = String.Join(", ", @class.Properties.Select(x => $"{x.TypeName.GetGlobalTypeName(defaultNamespace)} {x.PropertyName}"));
            string ctorAssignmentsStr = String.Join(Environment.NewLine, @class.Properties.Select(x => $"            {ToPascalCase(x.PropertyName)} = {x.PropertyName};"));
            string content = $@"{GeneratedCodeHeader}

namespace {defaultNamespace}
{{
{DefaultAnnotationsStr}
    {visibility} sealed class {@class.Name}
    {{
{propertiesStr}

        public {@class.Name}({ctorParametersStr})
        {{
{ctorAssignmentsStr}
        }}
    }}
}}";
            return content;
        }

        private static string GenerateEnum(string defaultNamespace, OpenApiEnum @enum)
        {
            string membersStr = String.Join($",{Environment.NewLine}", @enum.Members.Select(x => $"        {x.Name} = {x.Value}"));
            string content = $@"{GeneratedCodeHeader}

namespace {defaultNamespace}
{{
{GeneratedCodeAnnotationStr}
    public enum {@enum.Name}
    {{
{membersStr}
    }}
}}";
            return content;
        }

        private static void AddEndpointExtensions(SourceProductionContext context, string defaultNamespace, string? contractNamespace, ICollection<OpenApiOperationGroup> groups, IDictionary<string, OpenApiModel> modelMap)
        {
            string GenerateMapping(OpenApiOperationDescriptor operation)
            {
                string parametersStr = GenerateParameters(operation, defaultNamespace, contractNamespace, modelMap);
                if (parametersStr.Length > 0)
                    parametersStr = $"{parametersStr}, ";

                string parameterNamesStr = String.Join(", ", operation.Parameters.Select(x => x.ParameterName));
                if (parameterNamesStr.Length > 0)
                    parameterNamesStr = $", {parameterNamesStr}";

                return $"            yield return global::Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.MapPost(endpoints, \"{operation.Path}\", ({parametersStr}global::{defaultNamespace}.I{operation.Group.Name} handler, global::Microsoft.AspNetCore.Http.HttpContext context) => handler.{operation.MethodName}(context{parameterNamesStr}));";
            }

            string registrationsStr = String.Join(Environment.NewLine, groups.Select(x => $"            global::Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton<global::{defaultNamespace}.I{x.Name}, global::{defaultNamespace}.{x.Name}>(services);"));
            string mappingStr = String.Join(Environment.NewLine, groups.SelectMany(x => x.Operations).Select(GenerateMapping));
            string content = $@"{GeneratedCodeHeader}

namespace Microsoft.AspNetCore.Builder
{{
{DefaultAnnotationsStr}
    internal static class EndpointExtensions
    {{
        public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddGeneratedEndpoints(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
        {{
{registrationsStr}
            return services;
        }}

        public static global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder AddGeneratedEndpoints(this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints, string authorizationPolicyName = null)
        {{
            foreach (global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder builder in global::Microsoft.AspNetCore.Builder.EndpointExtensions.AddGeneratedEndpoints(endpoints))
            {{
                global::Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization(builder, authorizationPolicyName);
            }}
            return endpoints;
        }}
        private static global::System.Collections.Generic.IEnumerable<global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder> AddGeneratedEndpoints(this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints)
        {{
{mappingStr}
        }}
    }}
}}";
            context.AddSource("EndpointExtensions.g.cs", content);
        }

        private static void AddHubExtensions(SourceProductionContext context, string defaultNamespace, string? hubNamespace, IEnumerable<OpenApiOperationGroup> groups)
        {
            string methodsStr = String.Join($"{Environment.NewLine}{Environment.NewLine}", groups.Select(x => @$"        public static global::Microsoft.AspNetCore.Builder.HubEndpointConventionBuilder MapGeneratedHub<THub>(this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints) where THub : global::{hubNamespace ?? defaultNamespace}.{x.Name}
        {{
            return global::Microsoft.AspNetCore.Builder.HubEndpointRouteBuilderExtensions.MapHub<THub>(endpoints, ""{x.Path}"");
        }}"));
            string content = $@"{GeneratedCodeHeader}

namespace Microsoft.AspNetCore.Builder
{{
{DefaultAnnotationsStr}
    internal static class HubExtensions
    {{
{methodsStr}
    }}
}}";
            context.AddSource("HubEndpointRouteBuilderExtensions.g.cs", content);
        }

        private static string GenerateHubInterfaceMethod(OpenApiOperationDescriptor method, string defaultNamespace, string? contractNamespace, IDictionary<string, OpenApiModel> modelMap) => GenerateInterfaceMethod(method, defaultNamespace, contractNamespace, modelMap);

        private static string GenerateServiceInterfaceMethod(OpenApiOperationDescriptor method, string defaultNamespace, string? contractNamespace, IDictionary<string, OpenApiModel> modelMap)
        {
            void ModifyParameter(IList<string> parameters)
            {
                parameters.Insert(0, "global::Microsoft.AspNetCore.Http.HttpContext context");
            }
            return GenerateInterfaceMethod(method, defaultNamespace, contractNamespace, modelMap, ModifyParameter);
        }

        private static string GenerateInterfaceMethod(OpenApiOperationDescriptor method, string defaultNamespace, string? contractNamespace, IDictionary<string, OpenApiModel> modelMap, Action<IList<string>>? parametersHandler = null)
        {
            string parametersStr = GenerateParameters(method, defaultNamespace, contractNamespace, modelMap, parametersHandler);
            string content = $"        global::System.Threading.Tasks.Task {method.MethodName}({parametersStr});";
            return content;
        }

        private static string GenerateParameters(OpenApiOperationDescriptor method, string defaultNamespace, string? contractNamespace, IDictionary<string, OpenApiModel> modelMap, Action<IList<string>>? parametersHandler = null)
        {
            string GenerateParameter(OpenApiOperationParameter parameter)
            {
                string parameterNamespace = ResolveParameterNamespace(parameter.TypeName, defaultNamespace, contractNamespace, modelMap);
                return $"{parameter.TypeName.GetGlobalTypeName(parameterNamespace)} {parameter.ParameterName}";
            }

            IList<string> parameters = method.Parameters.Select(GenerateParameter).ToList();
            parametersHandler?.Invoke(parameters);
            string parametersStr = String.Join(", ", parameters);
            return parametersStr;
        }

        private static string ResolveParameterNamespace(OpenApiTypeName parameterType, string defaultNamespace, string? contractNamespace, IDictionary<string, OpenApiModel> modelMap)
        {
            if (parameterType.IsPrimitive)
                return "";

            if (!modelMap.TryGetValue(parameterType.Name, out OpenApiModel model))
                throw new InvalidOperationException($"Unknown schema reference: {parameterType.Name}");

            string resolvedNamespace = model.Usage == OpenApiModelUsage.Service ? defaultNamespace : contractNamespace ?? defaultNamespace;
            return resolvedNamespace;
        }

        private static IEnumerable<OpenApiModel> CollectModels(SourceProductionContext context, string path, IDictionary<string, OpenApiSchema> schemas)
        {
            foreach (KeyValuePair<string, OpenApiSchema> schemaPair in schemas)
            {
                string schemaName = schemaPair.Key;
                OpenApiSchema modelSchema = schemaPair.Value;

                bool isEnum = modelSchema.Enum.Any();

                OpenApiModel model;
                if (isEnum)
                {
                    OpenApiEnum @enum = new OpenApiEnum(schemaName);
                    model = @enum;

                    IDictionary<int, string> enumNameMap = new Dictionary<int, string>();
                    if (modelSchema.Extensions.TryGetValue(EnumVarNamesExtension, out IOpenApiExtension enumVarNamesValue) && enumVarNamesValue is OpenApiArray enumVarNamesArray)
                    {
                        enumNameMap.AddRange(enumVarNamesArray.Select((x, i) => new KeyValuePair<int, string>(i, ParseEnumVarName(x))));
                    }

                    for (int i = 0; i < modelSchema.Enum.Count; i++)
                    {
                        IOpenApiAny enumMember = modelSchema.Enum[i];
                        OpenApiEnumMember? member = ParseEnumMember(context, path, enumMember, i, enumNameMap);
                        if (member != null)
                            @enum.Members.Add(member.Value);
                    }
                }
                else
                {
                    OpenApiClass @class = new OpenApiClass(schemaName);
                    model = @class;

                    foreach (KeyValuePair<string, OpenApiSchema> propertyPair in modelSchema.Properties)
                    {
                        string propertyName = propertyPair.Key;
                        OpenApiSchema propertySchema = propertyPair.Value;
                        @class.Properties.Add(new OpenApiClassProperty(propertyName, GetCSharpTypeName(propertySchema)));
                    }
                }

                yield return model;
            }
        }

        private static void CollectOperations(OpenApiDocumentContainer container, IDictionary<OpenApiOperationGroupKey, OpenApiOperationGroup> operationGroupMap, IDictionary<string, OpenApiModel> modelMap)
        {
            foreach (KeyValuePair<string, OpenApiPathItem> pathPair in container.Document.Paths)
            {
                string path = pathPair.Key;
                OpenApiPathItem pathItem = pathPair.Value;

                foreach (KeyValuePair<OperationType, OpenApiOperation> operationPair in pathItem.Operations)
                {
                    OperationType method = operationPair.Key;
                    OpenApiOperation operation = operationPair.Value;
                    bool isWebSocket = IsWebSocket(operation);
                    string serviceName = GetServiceName(operation);
                    string methodName = operation.OperationId;
                    string operationGroupPath = GetPath(path);
                    OpenApiOperationGroupKey operationGroupKey = new OpenApiOperationGroupKey(serviceName, operationGroupPath, isWebSocket);
                    if (!operationGroupMap.TryGetValue(operationGroupKey, out OpenApiOperationGroup operationGroup))
                    {
                        operationGroup = new OpenApiOperationGroup(operationGroupKey);
                        operationGroupMap.Add(operationGroupKey, operationGroup);
                    }

                    OpenApiOperationDescriptor operationDescriptor = new OpenApiOperationDescriptor(operationGroup, methodName, path);

                    OpenApiSchema? bodySchema = operation.RequestBody?.Content.FirstOrDefault().Value?.Schema;
                    if (bodySchema != null)
                        operationDescriptor.Parameters.Add(new OpenApiOperationParameter("content", GetCSharpTypeName(bodySchema)));

                    foreach (OpenApiParameter parameter in operation.Parameters)
                    {
                        operationDescriptor.Parameters.Add(new OpenApiOperationParameter(parameter.Name, GetCSharpTypeName(parameter.Schema)));
                    }

                    foreach (string usedSchema in GetUsedSchemas(operationPair.Value))
                    {
                        OpenApiModelUsage usage = isWebSocket ? OpenApiModelUsage.Hub : OpenApiModelUsage.Service;
                        MarkSchemaAsUsed(modelMap, usedSchema, usage);
                    }

                    operationGroup.Operations.Add(operationDescriptor);
                }
            }
        }

        private static void MarkSchemaAsUsed(IDictionary<string, OpenApiModel> modelMap, string usedSchema, OpenApiModelUsage usage)
        {
            if (!modelMap.TryGetValue(usedSchema, out OpenApiModel model)) 
                return;

            model.Usage |= usage;

            if (model is not OpenApiClass @class) 
                return;

            foreach (OpenApiClassProperty property in @class.Properties)
            {
                MarkSchemaAsUsed(modelMap, property.TypeName.Name, usage);
            }
        }

        private static IEnumerable<string> GetUsedSchemas(OpenApiOperation operation)
        {
            IEnumerable<string> usedSchemas = GetUsedSchemaReferences(operation).Where(x => x != null)
                                                                                .SelectMany(x => x)
                                                                                .Select(x => x.Value.Schema.Reference.Id);

            return usedSchemas;
        }

        private static IEnumerable<IEnumerable<KeyValuePair<string, OpenApiMediaType>>> GetUsedSchemaReferences(OpenApiOperation operation)
        {
            if (operation.RequestBody != null)
                yield return operation.RequestBody.Content;

            yield return operation.Parameters.SelectMany(x => x.Content);
            yield return operation.Responses.SelectMany(x => x.Value.Content);
        }

        private static OpenApiTypeName GetCSharpTypeName(OpenApiSchema schema)
        {
            string? typeName = GetOpenApiTypeName(schema, out bool isPrimitive);
            switch (typeName)
            {
                // TODO: Finish implementation
                case null: return new OpenApiTypeName("void", isPrimitive: true);
                case "boolean": return new OpenApiTypeName("bool", isPrimitive: true);
                default: return new OpenApiTypeName(typeName, isPrimitive);
            }
        }
        private static string? GetOpenApiTypeName(OpenApiSchema schema, out bool isPrimitive)
        {
            if (schema.Reference != null)
            {
                isPrimitive = false;
                return schema.Reference.Id;
            }

            if (schema.Type != null)
            {
                isPrimitive = true;
                return schema.Type;
            }

            isPrimitive = false;
            return null;
        }

        private static bool IsWebSocket(IOpenApiExtensible extensible)
        {
            if (!extensible.Extensions.TryGetValue("x-websocket", out IOpenApiExtension extension))
                return false;

            return extension is OpenApiBoolean { Value: true };
        }

        private static string GetServiceName(OpenApiOperation operation) => operation.Tags.Any() ? operation.Tags[0].Name : "Default";

        private static string GetPath(string path)
        {
            int pathEndIndex = path.IndexOf('/', 1);
            if (pathEndIndex > 0)
            {
                string rootPath = path.Substring(0, pathEndIndex);
                return rootPath;
            }
            return path;
        }

        private static OpenApiDocumentContainer? LoadYamlFile(AdditionalText item, CancellationToken cancellationToken)
        {
            SourceText? text = item.GetText(cancellationToken);
            if (text == null)
                return null;

            OpenApiStringReader reader = new OpenApiStringReader();

            // TODO: What happens if the yaml file does not represent an OpenAPI document. Exception?
            OpenApiDocument document = reader.Read(text.ToString(), out OpenApiDiagnostic diagnostic);
            return new OpenApiDocumentContainer(item.Path, item, document, diagnostic);
        }

        private static void ReportOpenApiErrors(SourceProductionContext context, string path, OpenApiDiagnostic diagnostic)
        {
            foreach (OpenApiError error in diagnostic.Errors)
                ReportOpenApiError(DiagnosticSeverity.Error, error, path, context);

            foreach (OpenApiError warning in diagnostic.Warnings)
                ReportOpenApiError(DiagnosticSeverity.Warning, warning, path, context);
        }

        private static void ReportOpenApiError(DiagnosticSeverity severity, OpenApiError error, string path, SourceProductionContext context)
        {
            ReportDiagnostic(severity, ErrorCode.OpenApi, error.Pointer, error.Message, context, path);
        }

        private static void ReportDiagnostic(DiagnosticSeverity severity, string id, string title, string message, SourceProductionContext context, string path)
        {
            DiagnosticDescriptor descriptor = new DiagnosticDescriptor
            (
                id: id
              , title: title
              , messageFormat: message
              , category: nameof(OpenApiGenerator)
              , defaultSeverity: severity
              , isEnabledByDefault: true
            );
            context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.Create(path, new TextSpan(), new LinePositionSpan())));
        }

        private static bool IsAssemblyAttribute(SyntaxNode node, CancellationToken cancellationToken)
        {
            return node is AttributeListSyntax { Target: { } } attributeList && attributeList.Target.Identifier.IsKind(SyntaxKind.AssemblyKeyword);
        }

        private static SignalRHubGenerationOutputs? CollectOutputFilter(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            AttributeListSyntax attributeList = (AttributeListSyntax)context.Node;
            foreach (AttributeSyntax attribute in attributeList.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attribute).Symbol is not IMethodSymbol attributeSymbol)
                    return null;

                string displayString = attributeSymbol.ContainingType.ToDisplayString();
                if (displayString != AttributeTypeName)
                    return null;

                if (attribute.ArgumentList?.Arguments == null)
                    return null;

                SeparatedSyntaxList<AttributeArgumentSyntax> arguments = attribute.ArgumentList.Arguments;
                if (!arguments.Any())
                    return null;

                Optional<object?> outputFilterValue = context.SemanticModel.GetConstantValue(arguments[0].Expression);
                if (!outputFilterValue.HasValue)
                    return null;

                SignalRHubGenerationOutputs? outputFilter = (SignalRHubGenerationOutputs?)(int?)outputFilterValue.Value;
                return outputFilter;
            }
            return null;
        }

        private static string? GetRootNamespace(AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider)
        {
            return analyzerConfigOptionsProvider.GlobalOptions.TryGetValue("build_property.rootnamespace", out string? rootNamespace) ? rootNamespace : null;
        }

        private static string? GetMetadataProperty(AnalyzerConfigOptions options, string key)
        {
            _ = options.TryGetValue(key, out string? value);

            if (value == "")
                value = null;

            return value;
        }

        private static OpenApiEnumMember? ParseEnumMember(SourceProductionContext context, string path, IOpenApiAny enumMember, int index, IDictionary<int, string> enumNameMap)
        {
            switch (enumMember)
            {
                case OpenApiInteger @int:
                    int intValue = @int.Value;
                    if (!enumNameMap.TryGetValue(index, out string name))
                    {
                        ReportDiagnostic(DiagnosticSeverity.Error, ErrorCode.OpenApi, "OpenAPI document parsing error", $"Missing enum name for value '{intValue}'. Specify it using the {EnumVarNamesExtension} property.", context, path);
                        return null;
                    }
                    return new OpenApiEnumMember(name, intValue);

                case OpenApiString @string:
                    return new OpenApiEnumMember(@string.Value, index);

                default: throw new ArgumentOutOfRangeException(nameof(enumMember), enumMember, null);
            }
        }

        private static string ParseEnumVarName(IOpenApiAny value)
        {
            switch (value)
            {
                case OpenApiString @string: return @string.Value;
                default: throw new ArgumentOutOfRangeException(nameof(value), value, null);
            }
        }

        private static string NormalizeHubName(string hubName)
        {
            string normalizedHubName = hubName;
            const string hubSuffix = "Hub";
            if (normalizedHubName.EndsWith(hubSuffix, StringComparison.Ordinal))
                normalizedHubName = normalizedHubName.Substring(0, normalizedHubName.Length - hubSuffix.Length);

            return normalizedHubName;
        }

        private static string ComputeDefaultAnnotationsStr() => String.Join(Environment.NewLine, Annotation.All.Select(ComputeAnnotationStr));
        
        private static string ComputeGeneratedCodeAnnotationStr() => ComputeAnnotationStr(Annotation.GeneratedCode);

        private static string ComputeAnnotationStr(Annotation annotation) => $"    [{annotation.Name}{annotation.Arguments}]";

        private static string ToPascalCase(string s) => String.IsNullOrEmpty(s) ? s : $"{Char.ToUpperInvariant(s[0])}{s.Substring(1)}";

        private static string NormalizeEmbeddedSource(string content)
        {
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(content);
            EmbeddedSourceNormalizationVisitor visitor = new EmbeddedSourceNormalizationVisitor();
            SyntaxNode normalizedNode = visitor.Visit(syntaxTree.GetRoot());
            string normalizedContent = normalizedNode.ToFullString();
            return normalizedContent;
        }

        private sealed class EmbeddedSourceNormalizationVisitor : CSharpSyntaxRewriter
        {
            public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node) => node.WithAttributeLists(CreateAttributeLists(node, Annotation.All));

            public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node) => node.WithAttributeLists(CreateAttributeLists(node, EnumerableExtensions.Create(Annotation.GeneratedCode)));

            private static SyntaxList<AttributeListSyntax> CreateAttributeLists(MemberDeclarationSyntax node, IEnumerable<Annotation> annotations)
            {
                IEnumerable<AttributeListSyntax> attributeLists = annotations.Select(x => SyntaxFactory.AttributeList(new SeparatedSyntaxList<AttributeSyntax>().Add(CreateAttribute(x.Name, x.Arguments)))
                                                                                                       .WithLeadingTrivia(SyntaxFactory.Whitespace(new string(' ', 4)))
                                                                                                       .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)))
                                                                             .Concat(node.AttributeLists);
                return new SyntaxList<AttributeListSyntax>(attributeLists);
            }

            private static AttributeSyntax CreateAttribute(string name, string? arguments)
            {
                AttributeArgumentListSyntax? argumentList = null;
                if (arguments != null)
                    argumentList = SyntaxFactory.ParseAttributeArgumentList(arguments);

                AttributeSyntax attribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName(name), argumentList);
                return attribute;
            }
        }

        private static class ErrorCode
        {
            private const string Prefix = "OPENAPIGEN";
            
            public const string OpenApi = $"{Prefix}001";
        }

        private readonly struct OpenApiDocumentContainer
        {
            public string Path { get; }
            public AdditionalText SourceFile { get; }
            public OpenApiDocument Document { get; }
            public OpenApiDiagnostic Diagnostic { get; }

            public OpenApiDocumentContainer(string path, AdditionalText sourceFile, OpenApiDocument document, OpenApiDiagnostic diagnostic)
            {
                Path = path;
                SourceFile = sourceFile;
                Document = document;
                Diagnostic = diagnostic;
            }
        }

        private readonly struct OpenApiOperationGroupKey
        {
            public string Name { get; }
            public string Path { get; }
            public bool IsWebSocket { get; }

            public OpenApiOperationGroupKey(string name, string path, bool isWebSocket)
            {
                Name = name;
                Path = path;
                IsWebSocket = isWebSocket;
            }
        }

        private readonly struct OpenApiOperationGroup
        {
            public OpenApiOperationGroupKey Key { get; }
            public string Name => Key.Name;
            public string Path => Key.Path;
            public bool IsWebSocket => Key.IsWebSocket;
            public ICollection<OpenApiOperationDescriptor> Operations { get; }

            public OpenApiOperationGroup(OpenApiOperationGroupKey key)
            {
                Key = key;
                Operations = new Collection<OpenApiOperationDescriptor>();
            }
        }

        private readonly struct OpenApiOperationDescriptor
        {
            public OpenApiOperationGroup Group { get; }
            public string MethodName { get; }
            public string Path { get; }
            public ICollection<OpenApiOperationParameter> Parameters { get; }

            public OpenApiOperationDescriptor(OpenApiOperationGroup group, string methodName, string path)
            {
                Group = group;
                MethodName = methodName;
                Path = path;
                Parameters = new Collection<OpenApiOperationParameter>();
            }
        }

        private readonly struct OpenApiOperationParameter
        {
            public string ParameterName { get; }
            public OpenApiTypeName TypeName { get; }

            public OpenApiOperationParameter(string parameterName, OpenApiTypeName typeName)
            {
                ParameterName = parameterName;
                TypeName = typeName;
            }
        }

        [Flags]
        private enum OpenApiModelUsage
        {
            None    = 0,
            Hub     = 1,
            Service = 2,
            Both    = Hub | Service
        }

        private abstract class OpenApiModel
        {
            public string Name { get; }
            public OpenApiModelUsage Usage { get; set; }

            protected OpenApiModel(string name)
            {
                Name = name;
            }
        }

        private sealed class OpenApiClass : OpenApiModel
        {
            public ICollection<OpenApiClassProperty> Properties { get; }

            public OpenApiClass(string name) : base(name)
            {
                Properties = new Collection<OpenApiClassProperty>();
            }
        }

        private readonly struct OpenApiClassProperty
        {
            public string PropertyName { get; }
            public OpenApiTypeName TypeName { get; }

            public OpenApiClassProperty(string propertyName, OpenApiTypeName typeName)
            {
                PropertyName = propertyName;
                TypeName = typeName;
            }
        }

        private sealed class OpenApiEnum : OpenApiModel
        {
            public ICollection<OpenApiEnumMember> Members { get; }

            public OpenApiEnum(string name) : base(name)
            {
                Members = new Collection<OpenApiEnumMember>();
            }
        }

        private readonly struct OpenApiEnumMember
        {
            public string Name { get; }
            public int Value { get; }

            public OpenApiEnumMember(string name, int value)
            {
                Name = name;
                Value = value;
            }
        }

        private readonly struct OpenApiTypeName
        {
            public string Name { get; }
            public bool IsPrimitive { get; }

            public OpenApiTypeName(string name, bool isPrimitive)
            {
                Name = name;
                IsPrimitive = isPrimitive;
            }

            public string GetGlobalTypeName(string defaultNamespace)
            {
                StringBuilder sb = new StringBuilder(Name);
                if (!IsPrimitive)
                    sb.Insert(0, $"global::{defaultNamespace}.");

                string globalTypeName = sb.ToString();
                return globalTypeName;
            }
        }
    }
}